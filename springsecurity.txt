1-1 导学
2-1 开发环境安装（视频中有详细讲解）
	JDK
	STS
	Mysql
2-2 代码结构
	1、
	imooc-security:主模块
	imooc-security-core:核心业务逻辑
	imooc-security-browser:浏览器安全特定代码
	imooc-security-app:app相关特定代码
	imooc-security-demo:样例程序
	2、
	新建maven项目，勾选create a simple project，选择pom，1.0.0-SHAPSHOT
	其余四个项目就基于第一个，然后选择jar，1.0.0-SHAPSHOT
	3、
	在父项目pom中添加依赖管理，这里其实是使用了spring-io的依赖管理，可以在官网查看到，里面的依赖管理也是从官网copy的，使用这个的目的是如果你引用spring，hibernate等，可以不用自己写版本号，spring-io会帮助你选择合适的版本。
	还添加spring-cloud的依赖，
	添加编译环境1.8
	引入子模块，这时候其他4个子模块会报错是因为指定1.8，其他几个是1.5版本，这时候更新一下其他几个子模块即可
	4、
	core的pom文件
	browser的pom文件
	app的pom文件
	demo的pom文件
	5、idea创建项目
	https://www.cnblogs.com/wangmingshun/p/6383576.html
2-3 Hello Spring Security
	1、
		在demo项目中写springboot启动类DemoApplicaiton将其定为RestController
		启动项目会报错
		Description:
		Cannot determine embedded database driver class for database type NONE
		这是因为依赖了spring-boot-jdbc但没有配置
		在applicaiton.properties里配置数据库连接信息
	2、
		再次启动
		报错Error creating bean with name 'org.springframework.boot.autoconfigure.session.SessionAutoConfiguration$SessionRepositoryValidator': Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: No Spring Session store is configured: set the 'spring.session.store-type' property
		这是因为在browser里面配置了一个session依赖，先关掉spring.session.store-type=none
	3、
		再次启动
		启动成功，访问localhost：8080，弹出安全认证，这是springsecurity的默认认证
		关闭security.basic.enabled=false
	4、
		程序如何打包发布，在父项目中执行命令maven build...
		clean package
		这样每个项目的target文件夹下就有一个自己的jar包，但是这样是不行的
		demo项目应该是一个web项目，所以需要在demo的pom文件中加入插件，这样在demo文件夹会多一个jar包，这是一个可执行的jar
		可以用java -jar 这个jar包执行，就相当于启动main函数

3-1使用Spring Mvc开发RestFul API
	1、RestfulApi
		（1）用URL描述资源
		（2）使用HTTP方法描述行为，使用HTTP状态码来表示不同的结果
			GRT查
			POST增
			PUT改
			DELETE删
		（3）使用json交互数据
		（4）只是一种风格，并不是强制的标准
	2、REST成熟度模型
		（1）使用HTTP作为传输方式
		（2）引入资源概念，每个资源都有对应的URL
		（3）使用HTTP方法进行不同的的操作，使用HTTP状态吗来表示不同的结果
		（4）使用超媒体，在资源的表达中包含了链接信息
3-2查询请求
    1、编写针对RestfulAPI的测试用例
        编写对RestfulAPI的测试用例 依赖：后期引入测试用例
        	UserControllerTest类whenQuerySuccess方法
        	看上面对测试用例的的注解
        	在sts中添加偏好Favorite，静态导入
    2、使用注解声明RestfulAPI
    3、在RestfulAPI中传递参数
        @RestController标明此Controller提供restAPI
        @RequestMapping及其变体。映射HTTP请求：value = "/user",method = RequestMethod.GET
        @RequestParam映射请求参数：required = false,name = "username",value = "username",defaultValue = "zhhangsan"
        Pageable类分页对象，是springdata的对象如果用spring-data可以用这个非常方便，可以使用@PageableDefault默认值
        JSONPATH写法：在GitHub上面找

        400错误，表示没有请求

        System.out.println(ReflectionToStringBuilder.toString(userQueryCondition, ToStringStyle.MULTI_LINE_STYLE));

3-3用户详情服务
    1、@PathVariable映射url片段到java方法的参数
    2、在url声明中使用正则表达式
    3、@JsonView控制json输出内容

    编写用户详情服务whenGetInfoSuccess方法
    @PahtVariable：url中的片段作为值，参数中的正则表达式
    post方法的时候请求的时候需要多一个content
    使用正则表达式whenGetInfoFail方法
    @JsonView控制返回json的内容
    	使用接口来声明多个视图：在User类，用户详细视图可以继承简单视图
    	在值对象的get方法指定视图
    	在controller上指定视图
    .andReturn().getResponse().getContentAsString()测试用例中返回json字符串

 3-4处理创建请求
    1、@RequestBody映射请求到java方法的参数
    2、日期类型参数的处理
    3、@Valid注解和BindingResult验证请求参数的合法性并处理校验结果

    @RquestBody：请求中请求体
    whenCreateSuccess() 方法
    405请求method后台不支持，比如后台是get，而发是post
    日期类型参数的处理：不要传带格式的，传时间戳，由前台确定展示格式
    @Valid和BindingResult
    	在类中添加了notblank之后，需要在controller加valied注解
    	当有valid注解而没有BindingResult类在Controller时候，有错误的话，程序会返回404
    	当有BindingResult类的时候，程序会执行

3-5开发用户信息修改和删除服务
    1、常用的验证注解
    2、自定义消息
    3、自定义校验注解

    hibernate validator：所有注解都可以加message字段
    	whenUpdateSuccess()方法LocalDateTime1.8新加的类
    自己写注解验证
    	MyConstraint类
    		@Target({ElementType.METHOD,ElementType.FIELD})
    		@Retention(RetentionPolicy.RUNTIME)
    		@Constraint(validatedBy = MyConstraintValidator.class)

3-6 RESTful API错误处理
    1、SpringBoot默认的错误处理机制
    2、自定义异常处理

    SpringBoot默认错误处理机制（用的getInfo（）方法）：
	BasicErrorController 根据请求头作出判断：（这里看出同一个url有不同的处理）
	请求头里面有text/html，会进入public ModelAndView errorHtml方法
	没有的时候，会进入public ResponseEntity<Map<String, Object>> error方法
	当是浏览器访问时候，返回html，其它情况情况返回json（这种情况会是直接就没有进到方法里，在传入参数那里就直接返回错误了）
	springboot默认的错误处理返回的json的message是后端抛出异常的message

    自定义错误处理
	springboot自定义错误处理是基于状态码来处理的，
	在resources/resources/error文件夹中写状态码.html，这种只对浏览器访问有效，其他平台访问还是返回的json字符串

	新建exception包，新建类，自定义异常类，在controller类中抛出自定义异常类，但是springboot返回的json也只会返回message字段，
	如果想返回其他信息：新建类ControllerExceptionHandler类
	@ControllerAdvice注解表示这个类是用来处理Controller类抛出的异常的，本身不处理请求
	https://blog.csdn.net/w372426096/article/details/78429141
	方法handleUserNotExistException（）上面可以添加注解

3-7使用切片拦截Rest服务
    1、过滤器拦截
    2、拦截器拦截
    3、切片拦截

    需求：记录所有服务的处理时间

    过滤器：是javaee的规范，它不知道controller之类的东西
        TimeFilter：实现Filter接口，然后@Component让过滤器起作用
        但是如果是第三方的过滤器，它没有使用@Component注解，那么我们怎么让他起作用呢？
        传统的web项目中是web.xml添加过滤器，但是SpringBoot是没有配置文件的
        现在吧TimeFilter当成第三方，新建WebConfig类，注解@Configuration,然后在里面注入bean

    Spring注入Bean：（1）添加@Component之类的注解，spring会扫描这些注解，有时候也需要在配置类中额外添加扫描配置类@ComponentScan(basePackages = "com.dxz.demo.configuration")
                    （2）配置类，注入@Bean

    拦截器：
        TimeInterceptor implements HandlerInterceptor：
        //控制器处理之前调用：preHandle
        //控制器处理之后调用，如果controller层抛出异常，这个方法不会调用：postHandle
        //不管controller是正常运行，还是抛出异常，这个方法都会正常调用afterCompletion
        拦截器必须加@Component注解，还不够，还需要再WebConfig配置才可以，这时候
        WebCOnfig必须继承extends WebMvcConfigurerAdapter类，重写addInterceptors方法
        拦截器的finish方法当有异常发生的时候，异常还是返回空，是因为
                ControllerExceptionHandler已经把异常处理掉了
                当没有处理某类异常，会看到拦截器运行了两次
                第一次拦截的是UserController
                第二次拦截的是BasicErrorController
                拦截器会拦截所有的Controler，不管是不是自己写的

    切片：实际就是一个类
            切入点（注解：在哪些方法起作用，在什么时候起作用），增强（方法：起作用时执行的业务逻辑）
            要添加依赖，spring-boot-starter-aop
        	新建包aspect，新建类TimeAdpect，添加@Aspect@Component

    过滤器：原始http请求响应，拿不到具体处理的方法信息,不知道哪个controller处理的哪个方法处理的
    拦截器：上面两个都能拿到，但是拿不到方法真正被调用的时候传进来的参数的值（看sprig源码，DispatcherServlet——doservice方法——dodispatch方法962-971行，）
    切片：能拿到方法的参数的值，但是拿不到原始http请求响应
    执行顺序
    过滤器——拦截器——aspect—controller
    当controller层方法有异常：反方向并且多一个：过滤器——拦截器——aspect————ControllerAdvice——controller

3-9文件上传和下载

    whenUploadSuccess模拟前端文件上传
    FileController提供下载上传两种方法
    JDK1.7以后，try（）里面的东西可以jdk帮你关，不用写finally代码了
    添加commons-io包

3-10 异步处理REST服务
    使用Runnable异步处理Rest服务
    使用DeferredResult异步处理Rest服务
    异步处理配置

    tomcat处理的请求是有限制的，所有线程都在使用，所谓异步处理，就是主线程调用副线程，副线程处理好了，由主线程返回，在副线程处理过程中，主线程是可以处理其他请求的


    实际情况下常常是消息队列模式新建类MockQueue类

    1、同步处理 新建包async新建类AsyncController类order方法
    关掉上节课拦截器过滤器的打印

    2、异步处理 orders方法

    3、DeferredResult异步处理
     为什么还要用这个呢？
        Runable形式的异步处理，副线程必须是由主线程来调用的，真正的企业级开发场景比较复杂

     实际：
     处理下单请求和处理下单逻辑的并不是一台服务器
     1、http请求---应用1（线程1）---2、发消息---消息队列---3、监听并处理消息---应用2
     6、http响应---应用2（线程2）---5、监听处理结果---消息队列---4、发送处理结果---应用2
     线程1接收到HTTP请求的时候，会将这个请求放到消息队列中，当另一个服务器监听到请求的时候，由应用2来真正处理下单逻辑，
     再将处理结果放到消息队列，线程2监听订单处理结果，返回http响应，整个过程中，线程1和线程2完全是隔离的，

     不会去做应用2主要是4个代码
     用一个对象模拟消息队列，对象接收到下单请求后，延迟1秒，在消息队列中放订单完成的消息
     线程1的处理
     监听器的代码，监听订单完成的消息 QueueListener
     DeferredResultHolder在两个线程之间传递DeferredResult对象，

     异步方法拦截器的配置，不能直接用addInterceptor了

3-11 swagger
    与前端并行工作
    添加pom，然后在主函数使用@EnableSwagger2

3-12 使用wiremock伪造restful服务
    百度wiremock
    点击docs
    然后running as a standalone process，下载，
    然后启动jar包
    java -jar wiremock-standalone-2.13.0.jar --port


4-1 SpringSecurity开发基于表单的认证
    springsecurity主要用于：认证(你是谁)/授权(你能干什么)/攻击防护(防止伪造身份)
	内容：SpringSecurity基本原理
	    实现用户名+密码认证
	    实现手机号+短信认证（添加自定义认证方式）

4-2 SpringSecurity基本原理
    在classpath中如果由默认的security的相关jar包，springboot会默认开启，springboot默认将所有的服务都保护起来了，访问任何resuful服务，都要进行身份认证
    现在去把之前applicaiton中关闭的security打开.
    启动项目，访问随意一个资源，会发现springsecurity默认的身份认证弹框，用户名默认user，密码是程序启动生成的。
    开始写代码在其他的模块了，DEMO项目只是到时候引用安全模块。

    @Configuation等价于<Beans></Beans>
    @Bean等价于<Bean></Bean>
    @ComponentScan等价于<context:component-scan base-package="com.dxz.demo"/>
    @Configuration 相当于xml中的<beans>标签 @Bean相当于<bean>标签


    在browser项目写：
        新建BrowserSecurityConfig extends WebSecurityConfigurerAdapter（springsecurity提供的一个适配器类，web应用安全配置的适配器）


    springsecurity基本原理：其实是过滤器链
    过滤器链：
    	SecurityContextPersistenceFilter  请求的时候第一个，检查session里面是否有认证信息SecurityContext，如果有SecurityContext就从session拿出来放到线程里。响应返回的时候最后过它，检查线程是否有SecurityContext，如果有，就放到session里面去
    	
        绿色的过滤器每一个处理一种认证方式，它们的主要功能是检查当前的请求是不是有这个过滤器需要的信息
        UsernamePasswordAuthenticationFilter：检查请求是不是登录请求，登录请求中带没带用户名和密码，带了的该过滤器就会尝试用用户名和密码做登录，如果没有带，就会放过去，给下一个过滤器， 用户密码 前端访问路径要为login，POST，处理表单登录
    	BasicAuthenticationFilter ：检查请求头是不是有basic开头的authentication信息，有的话，会尝试拿出来做Base64解码做登录， springsecurity默认的
    	RememberMeAuthenticationFilter：记住我过滤器，其实是基于token的
        ...
    	以上都是可以通过配置实现是否过滤生效,主要用于用户认证方式

    	以下不能配置不起作用
    	ExceptionTranslationFilter  捕获FilterSecurityInterceptor抛出的异常，并且会根据配置引导用户到响应的界面（比如表单登录，它会到登录页面，比如基本登录，它会弹出登录框）
    	FilterSecurityInterceptor  最终方法的判断 ，决定当前的请求是否能访问后面的服务，就是根据我们的配置进行判断。这里如果不过就会抛出异常，在它身后就是我们的controller服务了
    	RestFul API

    断点模式看程序流程
    	UsernamePasswordAuthenticationFilter看到它只会处理/login post请求
    	ExceptionTranslationFilter 类的dofilter方法很简单，它的主要逻辑是在捕获exception中做了什么
    	在FilterSecurityInterceptor的124行的beforeInvocation方法打断点
    	访问/user进到FilterSecurityInterceptor的beforeInvocation方法，该方法会判断配置里说所有请求都需要认证，所以抛出异常，ExceptionTranslationFilter类捕获到异常，会重定向到应该到的界面，实现登录/login，这时候会进入UsernamePasswordAuthenticationFilter类，验证通过，又进入FilterSecurityInterceptor的124行的beforeInvocation方法,这次验证通过。


4-3 自定义用户认证逻辑
    1、处理用户信息获取逻辑
    2、处理用户校验逻辑
    3、处理密码加密解密

    用户信息获取逻辑/user
        用户信息获取是在封装到一个接口中的，只有一个方法，返回UserDetails对象，抛出UsernameNotFoundException，校验通过会把用户放到session中
        新建类MyUserDetailsService实现UserDetailsService接口
        重写UserDetails loadUserByUsername(String username)方法
    处理用户校验逻辑
        UserDetails接口：账号被锁，密码是否过期，账户是否锁定，账户是否冻结，自定义的时候可以自定义类然后继承UserDetails类
        isAccountNonExpired()账号是否过期，true没有过期
        isCredentialsNonExpired()密码是否过期
        isAccountNonLocked()账户是否锁定——+一般用于表示账户是否被冻结
        isEnabled()账户是否锁定————一般用于用户信息是否被删除了（假删除，用户表一个字段表示）
    处理密码加密解密
        要用这个：org.springframework.security.crypto.password PasswordEncoder接口
        先要注入spring在config类中注入，在要使用的地方Autowired
        encode()方法是注册的时候程序员调用的，
        matches是spring自己调用的，登录过程中拿到返回的UserDetail的password和用户登录输的password
        要在BrowserSecurityConfig类中配置@Bean:PasswordEncoder,这里可以返回security自带的，也可以返回自定义的一个加密逻辑

4-4 个性化认证流程
    自定义登录页面 http.formLogin().loginPage("。。。")
    自定义登录成功处理 AuthencationSuccessHandler
    自定义登录失败处理 AuthenticationFailureHandler


    自定义登录页面
        在resources目录新建html,在Config类中定义登录页面，但是会报错误，这个页面死循环了，需要将该登录页面设置为不需要认证与授权！！
        接着，在imooc-signIn.html设置表单登录，自定义了一个路径，但是也想要UsernamePassword过滤器去处理它,还是在Config类中定义。
        Could not verify the provided CSRF token because your session was not found.前端出现这个错误，是因为springsecurity提供了一个跨站请求的默认防护，先把这个防御功能关闭

        此时，还有相应的问题：
        1/发送的restful请求，需要认证，返回的是html，这是不合理的，返回的应该是json，这时我们需要做成，如果访问的是html请求，就返回html，如果不是，就返回json
        2/写了标准的登录页面，但是我们是要提供可重用的模块，如何让别人的项目自定义自己的页面，不定义的时候，用我们定义的页面

        所以解决方案是：
            接到html或者数据请求：判断是否需要身份认证——需要——跳转到一个自定义的Controller方法上，在方法内判断是否是html请求引起的跳转，如果是，就返回登录页面，如果不是，就返回401状态码和错误信息

        
        新建BrowserSecurityController类，由Controller处理url,并且修改Config中处理登录页的请求路径为访问该Controller的映射
        HttpSessionRequestCache类是是springsecurity提供的专门用来缓存请求的。
        在该类里面写requireAuthentication方法，如果是html请求，就返回html，如果是其他，就返回json
        但是要让引用该模块的用户自定义登录页面html，所以在demo项目中的application属性文件中配置imooc.security.browser.loginPage = /demo-signIn.html
        因为最后要管理这些配置项，所以我们用一个类来封装这些配置项
        系统配置封装：写在core模块SecurityProperties：包含下面这几个
                        BrowserProperties，
                        ValidateCodeProperties，
                        OAuth2Properties，
                        SocialProperties，

        还有一个SecurityCoreConfig类，这个配置类让SecurityProperties生效
        common-lang，StringUtils的endsWithIgnoreCase方法

    自定义登录成功处理
        https://github.com/FasterXML/jackson-databind：jackson类
        spring自定义的登录成功是一个跳转，但是现在不能这样
        browser中写imoocAuthenticationSuccessHandler implements AuthenticationSuccessHandler，
        import org.springframework.security.core.Authentication也是spring中的核心类，封装了认证信息，包括什么IP啊，session啊，认证通过后的用户信息，Authentication会根据登录的方式不同返回不同的信息;

    自定义登录失败处理
        和成功的方式一样


    因为是可重用的模块，所以应该考虑到各种方式，当不是前后端分离的模式的时候，可能spring默认的跳转页面错误处理更适合，所以需要一个配置来说明是要JSON还是html
    新建枚举类，说明是哪种方式，
    BrowesrProperties类中新增LoginType属性
    imoocAuthenticationSuccessHandler中注入SecurityProperties类，然后不实现那个AuthenticationSuccessHandler接口了，改为继承一个类SavedRequestAwareAuthenticationSuccessHandler这是spring默认的成功处理器

4-6 认证流程源码级详情
    认证处理流程说明
    认证结果如何在多个请求共享
    获取认证用户信息

    断点模式看程序流程
    	UsernamePasswordAuthenticationFilter的attemptAuthentication()方法,获得未认证的Authentication，
        然后返回AuthenticaionManager类,本身不包含验证的逻辑，它的作用是管理下面的AuthenticationProvider，
        真正的逻辑是在AuthenticationProvider中public Authentication authenticate(Authentication authentication)方法中，它有多种验证方式（用户名密码，微信。。。）,不同的provider支持的authentication是不一样的

    通过session实现请求共享：SecurityContextPersistenceFilter  请求的时候第一个，检查session里面是否有认证信息SecurityContext，如果有SecurityContext就从session拿出来放到线程里。响应返回的时候最后过它，检查线程是否有SecurityContext，如果有，就放到session里面去

4-7 图形验证码
    1、生成图形验证码
        根据随机数生成图片
        将随机数放到session中
        在将生成的图片写到接口的响应中

    2、在UsernamePasswordAuthenticationFilter类之前加一个图形验证码的过滤器
        ValidateCodeFilter extends OncePerRequestFilter，保证这个过滤器只会走一次

        新建ImageCode类，返回给前端的验证码
        ValidateCodeController，编写接口获取验证码，要在session中存值
        ValidateCodeFilter写验证逻辑，还需要在BrowserSecurityConfig配置过滤器

        运行程序，错误的消息返回太多，虽然失败但是仍然调用到了后面的登录
        修改：
            ImoocAuthenticationFailureHandler类onAuthenticationFailure()返回new SimpleResponse
            Filter验证不通过return


4-8 图片验证码重构
    配置图片基本参数
    验证码拦截接口可配置
    验证码的生成逻辑

        图形验证码基本参数配置：
            第一级：默认配置，imooc-security-core
                新建ImageCodeProperties类，ValidateCodeProperties类
            第二级：应用级配置：imooc-security-demo
                在application.yml中填写
            第三级： 请求级配置：配置值在调用接口时传递
                在ValidateCodeController中填写
                ServletRequestUtils.getIntParameter（）方法；

        验证码拦截接口可配置：
            在ImageCodeProperties添加属性private String url;修改ValidateCodeFilter中的方法
            AntPathMatcher类（spring的，注意一下）

        验证码的生成逻辑可配：
            要把一段逻辑做成可以配置的，我们需要吧这段逻辑封装到接口后面
            新建接口ValidateCodeGenerator类，实现类ImageCodeGenerator，把Controller类的图片生成的逻辑都放到这里面来
            把控制器里面用于生成图片验证码的一段逻辑删除、
            新建ValidateCodeBeanConfig配置类

            在增量的方式修改代码
            在demo中新建DemoImageCodeGenerator实现ValidateCodeGenerator，自定义业务逻辑，并且不修改源码


4-9 记住我
    记住我功能基本原理
    记住我功能具体实现
    记住我功能springsecurity源码解析

        其实就是基于token，登录成功认证成功，security会生成token，插入数据表，在cookie中返回给浏览器
        之后浏览器访问带着token，在数据表查找是否有该token，有的话就返回userid，然后userDeatailService登录

        修改BrowserSecurityConfig类，添加数据源的设置，
        修改BrowserProperties添加记住我过期时间字段

        配置BrowserSecurityConfig

4-10 短信验证码接口开发
    开发短信验证码接口
    校验短信验证码并登录
    重构代码

        在ValidateCodeController添加短信验证码接口
        模板方法模式重构验证逻辑
        依赖搜索

    




















